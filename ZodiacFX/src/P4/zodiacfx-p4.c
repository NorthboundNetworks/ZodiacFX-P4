/* Automatically generated by p4c-zodiacfx from test_parser.p4 on Wed Jul 24 16:15:54 2019
 */
#include "zodiacfx-p4.h"
#include <asf.h>
#include <string.h>
#include <stdlib.h>
#include "common.h"
#include "switch.h"


#define ZODIACFX_MASK(t, w) ((((t)(1)) << (w)) - (t)1)
#define BYTES(w) ((w) / 8)


void packet_in(uint8_t *p_uc_data, uint16_t zodiacfx_ul_size, uint8_t port){

    struct Headers_t headers = {
        .ethernet = {
            .zodiacfx_valid = 0
        },
        .ipv4 = {
            .zodiacfx_valid = 0
        },
    };

    uint16_t zodiacfx_packetOffsetInBits = 0;
    uint8_t *zodiacfx_packetStart = p_uc_data;
    struct zodiacfx_output fxout;
    struct zodiacfx_input fxin;
    fxin.input_port = port;

    goto start;

// Start of Parser
    start: {
/* extract(headers.ethernet)*/
        if (zodiacfx_ul_size < 112) {
            
            goto accept;
        }
        memcpy(&headers.ethernet.dstAddr, zodiacfx_packetStart + BYTES(zodiacfx_packetOffsetInBits), BYTES(64));
        headers.ethernet.dstAddr = htonll(headers.ethernet.dstAddr) >> 16;
        headers.ethernet.dstAddr &= ZODIACFX_MASK(uint64_t, 48);
        zodiacfx_packetOffsetInBits += 48;

        memcpy(&headers.ethernet.srcAddr, zodiacfx_packetStart + BYTES(zodiacfx_packetOffsetInBits), BYTES(64));
        headers.ethernet.srcAddr = htonll(headers.ethernet.srcAddr) >> 16;
        headers.ethernet.srcAddr &= ZODIACFX_MASK(uint64_t, 48);
        zodiacfx_packetOffsetInBits += 48;

        memcpy(&headers.ethernet.etherType, zodiacfx_packetStart + BYTES(zodiacfx_packetOffsetInBits), BYTES(16));
        headers.ethernet.etherType = htons(headers.ethernet.etherType);
        zodiacfx_packetOffsetInBits += 16;

        headers.ethernet.zodiacfx_valid = 1;
        switch (headers.ethernet.etherType) {
            case 0x800: goto ip;
            default: goto accept;
        }
    }
    ip: {
/* extract(headers.ipv4)*/
        if (zodiacfx_ul_size < 160) {
            
            goto accept;
        }
        memcpy(&headers.ipv4.version, zodiacfx_packetStart + BYTES(zodiacfx_packetOffsetInBits), BYTES(8));
        headers.ipv4.version >>= 4;
        headers.ipv4.version &= ZODIACFX_MASK(uint8_t, 4);
        zodiacfx_packetOffsetInBits += 4;

        memcpy(&headers.ipv4.ihl, zodiacfx_packetStart + BYTES(zodiacfx_packetOffsetInBits), BYTES(8));
        headers.ipv4.ihl &= ZODIACFX_MASK(uint8_t, 4);
        zodiacfx_packetOffsetInBits += 4;

        memcpy(&headers.ipv4.diffserv, zodiacfx_packetStart + BYTES(zodiacfx_packetOffsetInBits), BYTES(8));
        zodiacfx_packetOffsetInBits += 8;

        memcpy(&headers.ipv4.totalLen, zodiacfx_packetStart + BYTES(zodiacfx_packetOffsetInBits), BYTES(16));
        headers.ipv4.totalLen = htons(headers.ipv4.totalLen);
        zodiacfx_packetOffsetInBits += 16;

        memcpy(&headers.ipv4.identification, zodiacfx_packetStart + BYTES(zodiacfx_packetOffsetInBits), BYTES(16));
        headers.ipv4.identification = htons(headers.ipv4.identification);
        zodiacfx_packetOffsetInBits += 16;

        memcpy(&headers.ipv4.flags, zodiacfx_packetStart + BYTES(zodiacfx_packetOffsetInBits), BYTES(8));
        headers.ipv4.flags >>= 5;
        headers.ipv4.flags &= ZODIACFX_MASK(uint8_t, 3);
        zodiacfx_packetOffsetInBits += 3;

        memcpy(&headers.ipv4.fragOffset, zodiacfx_packetStart + BYTES(zodiacfx_packetOffsetInBits), BYTES(16));
        headers.ipv4.fragOffset = htons(headers.ipv4.fragOffset);
        headers.ipv4.fragOffset &= ZODIACFX_MASK(uint16_t, 13);
        zodiacfx_packetOffsetInBits += 13;

        memcpy(&headers.ipv4.ttl, zodiacfx_packetStart + BYTES(zodiacfx_packetOffsetInBits), BYTES(8));
        zodiacfx_packetOffsetInBits += 8;

        memcpy(&headers.ipv4.protocol, zodiacfx_packetStart + BYTES(zodiacfx_packetOffsetInBits), BYTES(8));
        zodiacfx_packetOffsetInBits += 8;

        memcpy(&headers.ipv4.hdrChecksum, zodiacfx_packetStart + BYTES(zodiacfx_packetOffsetInBits), BYTES(16));
        headers.ipv4.hdrChecksum = htons(headers.ipv4.hdrChecksum);
        zodiacfx_packetOffsetInBits += 16;

        memcpy(&headers.ipv4.srcAddr, zodiacfx_packetStart + BYTES(zodiacfx_packetOffsetInBits), BYTES(32));
        headers.ipv4.srcAddr = htonl(headers.ipv4.srcAddr);
        zodiacfx_packetOffsetInBits += 32;

        memcpy(&headers.ipv4.dstAddr, zodiacfx_packetStart + BYTES(zodiacfx_packetOffsetInBits), BYTES(32));
        headers.ipv4.dstAddr = htonl(headers.ipv4.dstAddr);
        zodiacfx_packetOffsetInBits += 32;

        headers.ipv4.zodiacfx_valid = 1;
        goto accept;
    }

    reject: { return 1; }


// Start of Pipeline
    accept:
    {
        {
if ((fxin.input_port == 1)) 
                fxout.output_port = 2;
            else 
                fxout.output_port = 1;
        }
    }

// Start of Deparser
    
gmac_write(p_uc_data, zodiacfx_ul_size, fxout.output_port);
}
